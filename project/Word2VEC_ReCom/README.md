##  进一步思考
所以我们用word2vec学会了哪些歌曲和哪些歌曲最接近。

我们来思考一些很现实同时又很难解决的问题。比如：

## 1.2.1  冷启动问题
我们经常会遇到冷启动的问题，比如没有任何信息的歌曲，我们如何对它做推荐呢？

如果是歌手发行的新歌曲，我们怎么进行推荐呢？
如果我听完(并收藏)了一首很冷门的歌，怎么进行推荐呢？
我们知道新歌(或者小众的歌)是非常难和其他的歌关联上的，我们有的信息太少了(很少有用户在它上面发生行为)。
 `````
1.1） 一种解决办法当然是推荐热门的歌曲，但是其实没从个人兴趣出发，我们知道这并不是最好的办法，并没有太大的卵用。

1.2） 我们把问题的粒度放粗一点，用同样的思路，比如一个可考虑的解决方案是，我们把歌曲的粒度上升到对应的歌手，把刚才的song_list替换成artist_list，重新用word2vec建模，这样我们可以得到和一个歌手最相关(接近)的歌手，再推荐这个歌手最热门的歌曲，相对1.1的方法针对性强一些。
 `````

## 1.2.2  用户兴趣预测问题
我们刚才完成的功能，类似酷狗音乐和网易音乐里针对一首歌的“相似音乐”，那么问题又来了，如果我们现在要对一个user用这套song2vec的方式推荐，我们怎么做呢？
 `````
每个人的兴趣都是有时效性的，这意味着说，3年前我喜欢王菲的歌，去年我喜欢五月天的歌，而今年我可能就改摇滚路线，喜欢汪峰的歌了。
每一首歌的热度也是不一样的，有一些热门的歌，如果用户能喜欢，当然是首选
那么，我们来做一个粗暴一点点的处理，把这2个维度拉进来，一起来针对一个用户做推荐。
把每个用户喜欢(收藏)过的歌，沿着时间轴排好，同时由近到远给不同的衰减因子(比如最近一首歌是1，前一首是0.98，再前一首是0.98^2，以此类推...)，
同时我们针对不同的歌曲热度，给定不同的推荐因子(比如热度100的是1，热度80的是0.9...)，
每一首歌都可以拿回一个song2vec的推荐列表和对应的相似度，对相似度以时间衰减因子和热度权重进行加权，最后的结果排序后，展示给用户。
 `````
但是我感觉没有必要采用1.2.2的方式，原因:
 `````
既然排序阶段（比如 DIN）已经可以建模时间权重、热度偏好等影响因子，那我们在 Word2Vec 召回阶段做这些加权是不是 “多此一举”？
答案是： 在工业级推荐系统中，确实应该将“时间衰减、热度加权”之类的行为建模逻辑交给排序模型（如 DIN）来处理，而不是提前在召回阶段手动加权。
时间衰减、热度加权等逻辑应该交给排序阶段的 DIN 来学习，而不是手工在 Word2Vec 的召回结果里加权。 召回阶段用 Word2Vec 找潜在相关歌曲就够了，保持轻量、高效、泛化好。
 `````